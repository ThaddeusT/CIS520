
CIS 520 - Programming Project #1

                   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Thaddeus Thomas Tuck thaddeus@k-state.edu
Chuohao Jiang chuohaoj@ksu.edu
Peng Tan peng5462@ksu.edu

---- PRELIMINARIES ----

                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
added threads/alarm.c 
added threads/alarm.h
To better control funtions directly dealing with alarms.
list alarm_list = List of alarms
int64_t prev_ticks = amount of ticks that have already occured
bool is_alarm = check if the thread is an alarm
dismiss_alarm = removes alarm from the list of alarms
alarm_init = initializes an alarm
set_alarm = sets when the alarm is supposed to wake up
alarm_check = check if the alarm is ready to wake up

added threads/fixpoint.h
To execute numerical calculations.

modified threads/init.c
To Ensure functionality

modified threads/thread.c
modified threads/thread.h
Added sort_thread_list= To sort the list of threads

modified devices/timer.c
To use the alarm.c functions
modified Makefile.build
To incorporate alarm.c, alarm.h, and fixpoint.h to ensure functionality.

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to your timer_sleep(),
>> including the effects of the timer interrupt handler.
Set_alarm is called.
Sets the awakentime to current time + the amount of the alarm.
Disables interupts
Add the alarm to the list of alarms
blocks the thread
renables interupts
When timer_interupt is called
Increment ticks
check alarms
if ticks = wakeup time
remove the alarm from the list
unblock the alarm

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?
Quickly runs through the list of alarms and only activates the alarms 
that are ready to go off, and then proceeds.

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

When multiple threads call timer_sleep() simultaneously, they do not effect eachother.
Because every thread has its own alarm with its own life time. It will never have
side effects on the other threads. When we put the alarms into and remove them from the 
alarm list we disable interupts. Only once the addition or removal is
complete will interupts be renabled.

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> other designs that you considered?
This design avoids busy waiting, by utilizing a list of alarms. This design
was the most elegant and more importantly functional design we could
have derived.


             PRIORITY SCHEDULING
             ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> B2: Explain the data structure used to track priority donation.
modified threads/thread.c

modified threads/thread.h


added thread_low_priority = compare the priority of two threads
added thread_insert_less_head = compare the two threads
modified thread_exit = check each thread if its ready to be unblocked
		       and removed from the list of threads
modified thread_yield = if a thread is ready it gets scheduled
added thread_yield_higher_prioprity = to yeild for the higher priority thread
modified thread_set_priority = set the priority of a thread to a new priority
added thread_set_priority_other = donate priority to currently running thread
added thread_calculate_priority_other = calculate current priorities

modified threads/synch.c

modified threads/synch.h

added lock_low_priority = compare two lock priorities
modified sema_up = added wake_up and current
unblock thread to be woken up
compare priority of woken up thread 

modified lock_init = set the lock priority
modified lock_aquire = adjusts locks sleeping until it becomes available

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?
By yeilding to higher priority threads and by ordering the list of threads based on
priority.

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?
Decrements lock semaphoe

When a thread wants to acquire a lock, firstly it will test whether the lock is in another thread's hand, if not so the thread aquire
the lock straitly. If unfortunately the lock is held by another thread, and lock->holder's priority is smaller than current_thread,
then donation happens. First I test whether donation happens because of the lock, if not set the thread_current()->priority to
lock->holder->old_priority. Then the lock is the current_thread's wanting lock. Then donation happens. Before donation, I record the
thread's priority in lock->older_priority, after donation I record the thread's priority in lock->later_priority. After donation the
lock->holder->priority changed, then I test whether the lock holder is also wainting another lock, if so doante_chain/donate_nest
happens. I invoke function thread_set_priority_other to complete the donation with recursion. In this function, donation will stop until
thread_current()->priority is not bigger than the holder's wantinglock->holder->priority or the holder is not waiting for another lock.

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.
sema_up the lock's semaphore
Removes the lock from the list of locks
Sets lock priority
Checks donation


---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?
Because each thread creates its own lock.

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?
This was the only design we considered.

              ADVANCED SCHEDULER [EXTRA CREDIT]
              =================================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

